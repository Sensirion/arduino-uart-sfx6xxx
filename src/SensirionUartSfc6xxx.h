/*
 * THIS FILE IS AUTOMATICALLY GENERATED
 *
 * Generator:     sensirion-driver-generator 0.22.0
 * Product:       sfc6xxx
 * Model-Version: 1.1
 */
/*
 * Copyright (c) 2023, Sensirion AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Sensirion AG nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef SENSIRIONUARTSFC6XXX_H
#define SENSIRIONUARTSFC6XXX_H

#include "Arduino.h"
#include <SensirionCore.h>

#define NO_ERROR 0
#define SFC6XXX_SHDLC_ADDR 0x00
#define SFC6XXX_SHDLC_ADDR 0x00
#define SFC6XXX_SHDLC_ADDR 0x00
#define SFC6XXX_SHDLC_ADDR 0x00

typedef enum {
    SET_SETPOINT_CMD_ID = 0x0,
    GET_SETPOINT_CMD_ID = 0x0,
    READ_MEASURED_VALUE_CMD_ID = 0x8,
    READ_AVERAGED_MEASURED_VALUE_CMD_ID = 0x8,
    SET_SETPOINT_AND_READ_MEASURED_VALUE_CMD_ID = 0x3,
    SET_USER_CONTROLLER_GAIN_CMD_ID = 0x22,
    GET_USER_CONTROLLER_GAIN_CMD_ID = 0x22,
    SET_USER_INIT_STEP_CMD_ID = 0x22,
    GET_USER_INIT_STEP_CMD_ID = 0x22,
    MEASURE_RAW_FLOW_CMD_ID = 0x30,
    MEASURE_RAW_THERMAL_CONDUCTIVITY_WITH_CLOSED_VALVE_CMD_ID = 0x30,
    MEASURE_TEMPERATURE_CMD_ID = 0x30,
    GET_NUMBER_OF_CALIBRATIONS_CMD_ID = 0x40,
    GET_CALIBRATION_VALIDITY_CMD_ID = 0x40,
    GET_CALIBRATION_GAS_ID_CMD_ID = 0x40,
    GET_CALIBRATION_GAS_UNIT_CMD_ID = 0x40,
    GET_CALIBRATION_FULLSCALE_CMD_ID = 0x40,
    GET_CURRENT_GAS_ID_CMD_ID = 0x44,
    GET_CURRENT_GAS_UNIT_CMD_ID = 0x44,
    GET_CURRENT_FULLSCALE_CMD_ID = 0x44,
    SET_CALIBRATION_CMD_ID = 0x45,
    GET_CALIBRATION_CMD_ID = 0x45,
    SET_CALIBRATION_VOLATILE_CMD_ID = 0x46,
    SET_SLAVE_ADDRESS_CMD_ID = 0x90,
    GET_SLAVE_ADDRESS_CMD_ID = 0x90,
    SET_BAUDRATE_CMD_ID = 0x91,
    GET_BAUDRATE_CMD_ID = 0x91,
    GET_PRODUCT_TYPE_CMD_ID = 0xd0,
    GET_PRODUCT_NAME_CMD_ID = 0xd0,
    GET_ARTICLE_CODE_CMD_ID = 0xd0,
    GET_SERIAL_NUMBER_CMD_ID = 0xd0,
    GET_VERSION_CMD_ID = 0xd1,
    DEVICE_RESET_CMD_ID = 0xd3,
} CmdId;

class SensirionUartSfc6xxx {
  public:
    SensirionUartSfc6xxx();
    /**
     * @brief Initializes the Sfc6xxx class.
     *
     * @param serial Arduino stream object to be used for communiction.
     */
    void begin(Stream& serial);

    /**
     * @brief Switch device off (close the valve by setting setpoint to 0)
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t closeValve();

    /**
     * @brief setSetpoint
     *
     * Set the flow setpoint as a physical value which is used by the flow
     * controller as reference input.
     *
     * @param[in] setpoint The new setpoint.
     *
     * @note The setpoint is set to 0 if calibration is changed.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t setSetpoint(float setpoint);

    /**
     * @brief getSetpoint
     *
     * Get the current flow setpoint as a physical value.
     *
     * @param[out] setpoint The current setpoint.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t getSetpoint(float& setpoint);

    /**
     * @brief readMeasuredValue
     *
     * The command returns the latest measured flow as physical value.
     *
     * @param[out] measuredValue The latest measured flow.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t readMeasuredValue(float& measuredValue);

    /**
     * @brief readAveragedMeasuredValue
     *
     * The command returns the average of given number of flow measurement as
     * physical value. A single measurement has a duration of 1ms, so the
     * command response time depends on the given number of measurements to
     * average.
     *
     * @param[in] measurements number of measurements to average (1..100)
     * @param[out] averagedMeasuredValue The averaged flow measurement.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t readAveragedMeasuredValue(uint8_t measurements,
                                      float& averagedMeasuredValue);

    /**
     * @brief setSetpointAndReadMeasuredValue
     *
     * This command is a combination of the two commands set_setpoint (0x00) and
     * read_measured_value (0x08). It is intended for process data exchange
     * (setpoint and flow) and saves a lot of protocol overhead compared to
     * separate command usage.
     *
     * @param[in] setpoint The new setpoint as physical value.
     * @param[out] measuredValue The latest measured flow as physical value.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t setSetpointAndReadMeasuredValue(float setpoint,
                                            float& measuredValue);

    /**
     * @brief setUserControllerGain
     *
     * Set the user controller gain.
     *
     * @param[in] gain The user controller gain to set.
     *
     * @note This configuration is not stored in non-volatile memory of the
     * device and thus not persists after a device reset.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t setUserControllerGain(float gain);

    /**
     * @brief getUserControllerGain
     *
     * Get the user controller gain.
     *
     * @param[out] gain The current user controller gain.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t getUserControllerGain(float& gain);

    /**
     * @brief setUserInitStep
     *
     * Set the init step of flow controller.
     *
     * @param[in] initStep the user init step to set.
     *
     * @note This configuration is not stored in non-volatile memory of the
     * device and thus not persists after a device reset.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t setUserInitStep(float initStep);

    /**
     * @brief getUserInitStep
     *
     * Get the user init step of flow controller.
     *
     * @param[out] initStep The current user init step.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t getUserInitStep(float& initStep);

    /**
     * @brief measureRawFlow
     *
     * Return the measured raw flow ticks from the sensor.
     *
     * @param[out] flow Measured raw flow in ticks.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t measureRawFlow(uint16_t& flow);

    /**
     * @brief measureRawThermalConductivityWithClosedValve
     *
     * Perform a thermal conductivity measurement and return the measured raw
     * tick value. The valve is automatically closed during the measurement.
     *
     * @param[out] thermalConductivity Measured raw thermal conductivity in
     * ticks.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t
    measureRawThermalConductivityWithClosedValve(uint16_t& thermalConductivity);

    /**
     * @brief measureTemperature
     *
     * Return the temperature of flow sensor.
     *
     * @param[out] temperature Measured temperature [°C].
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t measureTemperature(float& temperature);

    /**
     * @brief getNumberOfCalibrations
     *
     * Get the number of calibrations, i.e. how many calibration the device
     * memory is able to hold.
     *
     * @param[out] numberOfCalibrations Number of calibrations.
     *
     * @note Not all calibration actually contain a valid gas calibration. Use
     * the command get_calibration_validity to check which calibrations are
     * valid and thus can be activated.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t getNumberOfCalibrations(uint32_t& numberOfCalibrations);

    /**
     * @brief getCalibrationValidity
     *
     * Check whether there exists a valid calibration at a specific index or
     * not.
     *
     * @param[in] index The index to check whether there is a valid calibration
     * or not.
     * @param[out] validity Whether there exists a valid calibration at the
     * specified index or not.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t getCalibrationValidity(uint32_t index, bool& validity);

    /**
     * @brief getCalibrationGasId
     *
     * Get the gas ID of a specific calibration index.
     *
     * @param[in] index The calibration index to read the requested information
     * from.
     * @param[out] gasId The read gas ID.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t getCalibrationGasId(uint32_t index, uint32_t& gasId);

    /**
     * @brief getCalibrationGasUnit
     *
     * Get the gas unit of a specific calibration index.
     *
     * @param[in] index The calibration index to read the requested information
     * from.
     * @param[out] prefix Medium unit prefix, see appendix for encoding.
     * @param[out] unit Medium unit, see appendix for encoding.
     * @param[out] timebase Timebase, see appendix for encoding.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t getCalibrationGasUnit(uint32_t index, int8_t& prefix, uint8_t& unit,
                                  uint8_t& timebase);

    /**
     * @brief getCalibrationFullscale
     *
     * Get the fullscale flow of a specific calibration index.
     *
     * @param[in] index The calibration index to read the requested information
     * from.
     * @param[out] fullscale The read fullscale flow in the unit of the
     * corresponding calibration.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t getCalibrationFullscale(uint32_t index, float& fullscale);

    /**
     * @brief getCurrentGasId
     *
     * Get the gas ID of the currently active calibration.
     *
     * @param[out] gasId The read gas ID.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t getCurrentGasId(uint32_t& gasId);

    /**
     * @brief getCurrentGasUnit
     *
     * Get the gas unit of the currently active calibration.
     *
     * @param[out] prefix Medium unit prefix, see datasheet for encoding.
     * @param[out] unit Medium unit, see datasheet for encoding.
     * @param[out] timebase Timebase, see datasheet for encoding.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t getCurrentGasUnit(int8_t& prefix, uint8_t& unit, uint8_t& timebase);

    /**
     * @brief getCurrentFullscale
     *
     * Get the fullscale flow of the currently active calibration.
     *
     * @param[out] fullscale The read fullscale flow in the unit of the
     * corresponding calibration.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t getCurrentFullscale(float& fullscale);

    /**
     * @brief setCalibration
     *
     * This command stops the controller, changes the used calibration of the
     * flow controller and starts the controller. The selected calibration is
     * stored and also used after a power-on or reset.
     *
     * @param[in] calibrationNumber The calibration number to activate.
     *
     * @note This command will cause a write operation in a flash. Because of
     * the limited write cycles of the flash, this command should not be called
     * periodically with new calibration (max. 50’000 times). If calibration is
     * already selected the function will not do a write cycle to flash.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t setCalibration(uint32_t calibrationNumber);

    /**
     * @brief getCalibration
     *
     * Get the actual set calibration number of flow controller.
     *
     * @param[out] calibrationNumber The current activated calibration number.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t getCalibration(uint32_t& calibrationNumber);

    /**
     * @brief setCalibrationVolatile
     *
     * This command stops the controller, changes the used calibration of the
     * flow controller and starts the controller. The selected calibration is
     * not stored to a non volatile memory.
     *
     * @param[in] calibrationNumber The calibration number to activate.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t setCalibrationVolatile(uint32_t calibrationNumber);

    /**
     * @brief setSlaveAddress
     *
     * Sets the SHDLC slave address of the device.
     *
     * @param[in] slaveAddress The new slave address to set.
     *
     * @note The slave address is stored in non-volatile memory of the device
     * and thus persists after a device reset. So the next time connecting to
     * the device, you have to use the new address. When changing the address of
     * a slave, make sure there isn't already a slave with that address on the
     * same bus! In that case you would get communication issues which can only
     * be fixed by disconnecting one of the slaves.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t setSlaveAddress(uint8_t slaveAddress);

    /**
     * @brief getSlaveAddress
     *
     * Gets the SHDLC slave address of the device.
     *
     * @param[out] slaveAddress The current slave address of the device.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t getSlaveAddress(uint8_t& slaveAddress);

    /**
     * @brief setBaudrate
     *
     * Sets the SHDLC baudrate of the device.
     *
     * @param[in] baudrate The new baudrate in bit/s. Allowed values are 9600,
     * 19200, 38400, 57600 and 115200 (default)
     *
     * @note The baudrate is stored in non-volatile memory of the device and
     * thus persists after a device reset. So the next time connecting to the
     * device, you have to use the new baudrate.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t setBaudrate(uint32_t baudrate);

    /**
     * @brief getBaudrate
     *
     * Gets the SHDLC baudrate of the device.
     *
     * @param[out] baudrate Current baudrate in bit/s.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t getBaudrate(uint32_t& baudrate);

    /**
     * @brief getProductType
     *
     * Gets the product type from the device.
     *
     * @param[out] productType String containing the product type.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t getProductType(int8_t productType[], uint16_t productTypeSize);

    /**
     * @brief getProductName
     *
     * Gets the product name from the device.
     *
     * @param[out] productName String containing the product name.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t getProductName(int8_t productName[], uint16_t productNameSize);

    /**
     * @brief getArticleCode
     *
     * Get the article code of the device. This information is also contained on
     * the product label.
     *
     * @param[out] articleCode The article code as an ASCII string.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t getArticleCode(int8_t articleCode[], uint16_t articleCodeSize);

    /**
     * @brief getSerialNumber
     *
     * Gets the serial number of the SFC6xxx sensor.
     *
     * @param[out] serialNumber String containing the serial number of the
     * SFC6xxx sensor.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t getSerialNumber(int8_t serialNumber[], uint16_t serialNumberSize);

    /**
     * @brief getVersion
     *
     * Gets the version information for the hardware, firmware and SHDLC
     * protocol.
     *
     * @param[out] firmwareMajor Firmware major version number.
     * @param[out] firmwareMinor Firmware minor version number.
     * @param[out] firmwareDebug Firmware debug state. If the debug state is
     * set, the firmware is in development.
     * @param[out] hardwareMajor Hardware major version number.
     * @param[out] hardwareMinor Hardware minor version number.
     * @param[out] protocolMajor Protocol major version number.
     * @param[out] protocolMinor Protocol minor version number.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t getVersion(uint8_t& firmwareMajor, uint8_t& firmwareMinor,
                       bool& firmwareDebug, uint8_t& hardwareMajor,
                       uint8_t& hardwareMinor, uint8_t& protocolMajor,
                       uint8_t& protocolMinor);

    /**
     * @brief deviceReset
     *
     * Executes a reset on the device. This has the same effect as a power
     * cycle.
     *
     * @note The device will reply before excecuting the reset.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t deviceReset();

  private:
    Stream* _serial = nullptr;
};

#endif  // SENSIRIONUARTSFC6XXX_H