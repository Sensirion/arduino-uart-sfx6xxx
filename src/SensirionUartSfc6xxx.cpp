/*
 * THIS FILE IS AUTOMATICALLY GENERATED
 *
 * Generator:     sensirion-driver-generator 0.22.0
 * Product:       sfc6xxx
 * Model-Version: 1.1
 */
/*
 * Copyright (c) 2023, Sensirion AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Sensirion AG nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "SensirionUartSfc6xxx.h"
#include <Arduino.h>

static uint8_t communication_buffer[140] = {0};

SensirionUartSfc6xxx::SensirionUartSfc6xxx() {
}

int16_t SensirionUartSfc6xxx::closeValve() {
    int16_t localError = 0;
    localError = setSetpoint(0);
    return localError;
}

int16_t SensirionUartSfc6xxx::setSetpoint(float setpoint) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 20);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 20);
    localError = txFrame.begin(0x0, SFC6XXX_SHDLC_ADDR, 5);
    localError |= txFrame.addUInt8(1);
    localError |= txFrame.addFloat(setpoint);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    return localError;
}

int16_t SensirionUartSfc6xxx::getSetpoint(float& setpoint) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 20);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 20);
    localError = txFrame.begin(0x0, SFC6XXX_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(1);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getFloat(setpoint);
    return localError;
}

int16_t SensirionUartSfc6xxx::readMeasuredValue(float& measuredValue) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 20);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 20);
    localError = txFrame.begin(0x8, SFC6XXX_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(1);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getFloat(measuredValue);
    return localError;
}

int16_t
SensirionUartSfc6xxx::readAveragedMeasuredValue(uint8_t measurements,
                                                float& averagedMeasuredValue) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 20);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 20);
    localError = txFrame.begin(0x8, SFC6XXX_SHDLC_ADDR, 2);
    localError |= txFrame.addUInt8(17);
    localError |= txFrame.addUInt8(measurements);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)200 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getFloat(averagedMeasuredValue);
    return localError;
}

int16_t
SensirionUartSfc6xxx::setSetpointAndReadMeasuredValue(float setpoint,
                                                      float& measuredValue) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 20);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 20);
    localError = txFrame.begin(0x3, SFC6XXX_SHDLC_ADDR, 5);
    localError |= txFrame.addUInt8(1);
    localError |= txFrame.addFloat(setpoint);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getFloat(measuredValue);
    return localError;
}

int16_t SensirionUartSfc6xxx::setUserControllerGain(float gain) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 20);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 20);
    localError = txFrame.begin(0x22, SFC6XXX_SHDLC_ADDR, 5);
    localError |= txFrame.addUInt8(0);
    localError |= txFrame.addFloat(gain);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    return localError;
}

int16_t SensirionUartSfc6xxx::getUserControllerGain(float& gain) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 20);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 20);
    localError = txFrame.begin(0x22, SFC6XXX_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(0);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getFloat(gain);
    return localError;
}

int16_t SensirionUartSfc6xxx::setUserInitStep(float initStep) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 20);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 20);
    localError = txFrame.begin(0x22, SFC6XXX_SHDLC_ADDR, 5);
    localError |= txFrame.addUInt8(3);
    localError |= txFrame.addFloat(initStep);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    return localError;
}

int16_t SensirionUartSfc6xxx::getUserInitStep(float& initStep) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 20);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 20);
    localError = txFrame.begin(0x22, SFC6XXX_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(3);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getFloat(initStep);
    return localError;
}

int16_t SensirionUartSfc6xxx::measureRawFlow(uint16_t& flow) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 16);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 16);
    localError = txFrame.begin(0x30, SFC6XXX_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(0);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getUInt16(flow);
    return localError;
}

int16_t SensirionUartSfc6xxx::measureRawThermalConductivityWithClosedValve(
    uint16_t& thermalConductivity) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 16);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 16);
    localError = txFrame.begin(0x30, SFC6XXX_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(2);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)600 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getUInt16(thermalConductivity);
    return localError;
}

int16_t SensirionUartSfc6xxx::measureTemperature(float& temperature) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 20);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 20);
    localError = txFrame.begin(0x30, SFC6XXX_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(16);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getFloat(temperature);
    return localError;
}

int16_t
SensirionUartSfc6xxx::getNumberOfCalibrations(uint32_t& numberOfCalibrations) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 20);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 20);
    localError = txFrame.begin(0x40, SFC6XXX_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(0);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getUInt32(numberOfCalibrations);
    return localError;
}

int16_t SensirionUartSfc6xxx::getCalibrationValidity(uint32_t index,
                                                     bool& validity) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 20);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 20);
    localError = txFrame.begin(0x40, SFC6XXX_SHDLC_ADDR, 5);
    localError |= txFrame.addUInt8(16);
    localError |= txFrame.addUInt32(index);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getBool(validity);
    return localError;
}

int16_t SensirionUartSfc6xxx::getCalibrationGasId(uint32_t index,
                                                  uint32_t& gasId) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 20);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 20);
    localError = txFrame.begin(0x40, SFC6XXX_SHDLC_ADDR, 5);
    localError |= txFrame.addUInt8(18);
    localError |= txFrame.addUInt32(index);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getUInt32(gasId);
    return localError;
}

int16_t SensirionUartSfc6xxx::getCalibrationGasUnit(uint32_t index,
                                                    int8_t& prefix,
                                                    uint8_t& unit,
                                                    uint8_t& timebase) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 20);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 20);
    localError = txFrame.begin(0x40, SFC6XXX_SHDLC_ADDR, 5);
    localError |= txFrame.addUInt8(19);
    localError |= txFrame.addUInt32(index);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getInt8(prefix);
    localError |= rxFrame.getUInt8(unit);
    localError |= rxFrame.getUInt8(timebase);
    return localError;
}

int16_t SensirionUartSfc6xxx::getCalibrationFullscale(uint32_t index,
                                                      float& fullscale) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 20);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 20);
    localError = txFrame.begin(0x40, SFC6XXX_SHDLC_ADDR, 5);
    localError |= txFrame.addUInt8(20);
    localError |= txFrame.addUInt32(index);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getFloat(fullscale);
    return localError;
}

int16_t SensirionUartSfc6xxx::getCurrentGasId(uint32_t& gasId) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 20);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 20);
    localError = txFrame.begin(0x44, SFC6XXX_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(18);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getUInt32(gasId);
    return localError;
}

int16_t SensirionUartSfc6xxx::getCurrentGasUnit(int8_t& prefix, uint8_t& unit,
                                                uint8_t& timebase) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 18);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 18);
    localError = txFrame.begin(0x44, SFC6XXX_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(19);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getInt8(prefix);
    localError |= rxFrame.getUInt8(unit);
    localError |= rxFrame.getUInt8(timebase);
    return localError;
}

int16_t SensirionUartSfc6xxx::getCurrentFullscale(float& fullscale) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 20);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 20);
    localError = txFrame.begin(0x44, SFC6XXX_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(20);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getFloat(fullscale);
    return localError;
}

int16_t SensirionUartSfc6xxx::setCalibration(uint32_t calibrationNumber) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 18);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 18);
    localError = txFrame.begin(0x45, SFC6XXX_SHDLC_ADDR, 4);
    localError |= txFrame.addUInt32(calibrationNumber);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    return localError;
}

int16_t SensirionUartSfc6xxx::getCalibration(uint32_t& calibrationNumber) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 20);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 20);
    localError = txFrame.begin(0x45, SFC6XXX_SHDLC_ADDR, 0);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getUInt32(calibrationNumber);
    return localError;
}

int16_t
SensirionUartSfc6xxx::setCalibrationVolatile(uint32_t calibrationNumber) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 18);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 18);
    localError = txFrame.begin(0x46, SFC6XXX_SHDLC_ADDR, 4);
    localError |= txFrame.addUInt32(calibrationNumber);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    return localError;
}

int16_t SensirionUartSfc6xxx::setSlaveAddress(uint8_t slaveAddress) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 12);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 12);
    localError = txFrame.begin(0x90, SFC6XXX_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(slaveAddress);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    return localError;
}

int16_t SensirionUartSfc6xxx::getSlaveAddress(uint8_t& slaveAddress) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 14);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 14);
    localError = txFrame.begin(0x90, SFC6XXX_SHDLC_ADDR, 0);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getUInt8(slaveAddress);
    return localError;
}

int16_t SensirionUartSfc6xxx::setBaudrate(uint32_t baudrate) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 18);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 18);
    localError = txFrame.begin(0x91, SFC6XXX_SHDLC_ADDR, 4);
    localError |= txFrame.addUInt32(baudrate);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    return localError;
}

int16_t SensirionUartSfc6xxx::getBaudrate(uint32_t& baudrate) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 20);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 20);
    localError = txFrame.begin(0x91, SFC6XXX_SHDLC_ADDR, 0);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getUInt32(baudrate);
    return localError;
}

int16_t SensirionUartSfc6xxx::getProductType(int8_t productType[],
                                             uint16_t productTypeSize) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 140);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 140);
    localError = txFrame.begin(0xd0, SFC6XXX_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(0);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getBytes((uint8_t*)productType, productTypeSize);
    return localError;
}

int16_t SensirionUartSfc6xxx::getProductName(int8_t productName[],
                                             uint16_t productNameSize) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 140);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 140);
    localError = txFrame.begin(0xd0, SFC6XXX_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(1);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getBytes((uint8_t*)productName, productNameSize);
    return localError;
}

int16_t SensirionUartSfc6xxx::getArticleCode(int8_t articleCode[],
                                             uint16_t articleCodeSize) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 140);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 140);
    localError = txFrame.begin(0xd0, SFC6XXX_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(2);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getBytes((uint8_t*)articleCode, articleCodeSize);
    return localError;
}

int16_t SensirionUartSfc6xxx::getSerialNumber(int8_t serialNumber[],
                                              uint16_t serialNumberSize) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 140);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 140);
    localError = txFrame.begin(0xd0, SFC6XXX_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(3);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getBytes((uint8_t*)serialNumber, serialNumberSize);
    return localError;
}

int16_t
SensirionUartSfc6xxx::getVersion(uint8_t& firmwareMajor, uint8_t& firmwareMinor,
                                 bool& firmwareDebug, uint8_t& hardwareMajor,
                                 uint8_t& hardwareMinor, uint8_t& protocolMajor,
                                 uint8_t& protocolMinor) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 26);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 26);
    localError = txFrame.begin(0xd1, SFC6XXX_SHDLC_ADDR, 0);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getUInt8(firmwareMajor);
    localError |= rxFrame.getUInt8(firmwareMinor);
    localError |= rxFrame.getBool(firmwareDebug);
    localError |= rxFrame.getUInt8(hardwareMajor);
    localError |= rxFrame.getUInt8(hardwareMinor);
    localError |= rxFrame.getUInt8(protocolMajor);
    localError |= rxFrame.getUInt8(protocolMinor);
    return localError;
}

int16_t SensirionUartSfc6xxx::deviceReset() {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 12);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 12);
    localError = txFrame.begin(0xd3, SFC6XXX_SHDLC_ADDR, 0);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)100 * 1000);
    if (localError != NO_ERROR) {
        return localError;
    }
    delay(300);
    return localError;
}

void SensirionUartSfc6xxx::begin(Stream& serial) {
    _serial = &serial;
}
